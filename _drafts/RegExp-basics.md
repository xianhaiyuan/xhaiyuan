这里不会对正则的背景进行介绍，将直接对正则的使用进行讲解。

> 注意：有一些文章和书本可能为了让正则表达式看起来不那么密密麻麻，而在正则表达式里加了空格隔开，例如`/(\w+)\s(\w+)/`,这个表达式可以匹配Hello RegExp，但有的文章和书本里写成`/(\w+) \s (\w+)/`，这样的话就不是匹配Hello RegExp，而是匹配Hello RegExp中间再加两个空格。  

## Javascript正则表达式的定义 ##
1.构造函数定义

构造函数定义接受两个参数，一个是要匹配的字符串模式(注意此参数是字符串，不能是正则表达式字面量)，另一个是可选的标志字符串，即g,i,m


```javascript
var reg = new RegExp("java[script]",'gim');    
```

g,i,m为可选属性。

- g--全文查找，即模式被应用于所有字符串，而并非在发现第一个匹配项时立即停止
- i--忽略大小写
- m--多行查找，即在到达一行文本末尾时还会继续查找下一行中是否存在模式匹配的项


2.字面量定义

```javascript
var reg = /(\w+)\s(\w+)/;
```

3.构造函数定义与字面量定义比较

由于构造函数定义的参数是字符串，所以在某些情况下要对字符串进行双重转义。另外所有的元字符都必须进行双重转义，那些已经转义过的字符串也是如此，以下左边为字面量模式，右边为等价的构造函数定义时使用的字符串参数。

| 字面量模式        | 等价的字符串           |
| ------------- |:-------------:|
| /\w/ | "\\\\w"|
| /\\[java\\]script/ | "\\\\[java\\\\]script" |
| /\\.com/ | "\\\\.com" |
| /China\/Eng/ | "China\\\\/Eng" |
| /\d\\.\d{1,2}/ | "\\\\d\\\\.\\\\d{1,2}" |
| /\w\\\\hello | "\\\\w\\\\\\\\hello" |

在ECMAScript3中，正则表达式字面量会始终共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp都是一个新的实例。

```javascript
var reg = null,i;

for (i = 0; i < 10; i++){
	reg = /java/g;
	reg.test("javascript");
}

for (i = 0; i < 10; i++){
	reg = new RegExp("java","g");
	reg.test("javascript");
}
```

第一个循环中第一次调用test()找到了"java",但第二次调用从索引为3(上一次匹配的末尾)的字符开始,所以第二次就匹配不到，由于匹配会一直找到字符串末尾，所以下一次再调用test()又会重头开始。

第二个循环使用构造函数在每次循环中创建正则表达式，因为每次迭代都会创建一个新的RegExp实例，所以每次调用test()都会返回true。

注意，在ECMAScript5中，正则表达式字面量和构造函数一样，每次都会创建新的RegExp实例。所以ECMAScript5往后上面两个循环结果都一样。
